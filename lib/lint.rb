require 'yaml'
require 'crichton'

module Lint
   MAJOR_SECTIONS = %w(states descriptors protocols)

   # check for a variety of errors and other synctical issues in a resource descriptor file's contents
  def self.validate(filename)
     warnings = []
     errors = []
     resource_names = []

     #  Look for major foobars / other massively bad errors
     check_for_missing_sections(filename, errors)

    # Load the file into the registry generated by crichton
     registry = load_single_descriptor_file_into_registry(filename, errors)

    #6 save off resource names, major foobar if no secondary resources are found
    if registry.keys.empty?
      errors << ("\tERROR:  At least one resource type must be defined (e.g. object, collection, etc.) in states: and descriptors: sections")
    end

     # At this point, if  any errors are encountered, they are so massive that it is not worth the continuation of processing
     unless errors.empty?
       display_results  errors, warnings
       return
     end

    # extract the names of the major secondary resources. These are usually a single object and its collection, but not in all cases
    resource_names = registry.keys

    #7,8 Check for second level egregious errors
    resource_names.each do |resource_type|
      errors << ("\tERROR:  No states defined for resource  ") << resource_type if registry[resource_type].parent_descriptor.states.empty?
      errors << ("\tERROR:  No descriptors defined for resource  ") << resource_type if registry[resource_type].parent_descriptor.descriptors.empty?
    end

     #10, #11, #12, #13 check for the presence of required attributes for all transitions
     check_for_required_state_transition_properties(resource_names, registry, errors, warnings)

    #36 we know the protocol section exists, check to see if it has a media type
     errors << "\tERROR:  No protocol media type section defined  " if registry[resource_names[0]].parent_descriptor.protocols.empty?

    # do output
     display_results  errors, warnings
  end


   # core deep dive method looking for missing properties and other syntactical errors down to the transitions of the states: section
   def self.check_for_required_state_transition_properties resource_names, registry, errors, warnings
      # build a list of states for all secondary descriptors
      states = build_state_list(resource_names, registry)

      resource_names.each do |resource_type|
        if get_states_for_secondary_descriptor(registry, resource_type).empty?
          errors << "\tERROR:  No state transitions defined for resource " << resource_type
        else
          get_states_for_secondary_descriptor(registry, resource_type).each do |state|
            curr_state= state[1]
          #16
            warnings << ("\tWARNING: resource " << resource_type << ", state " << curr_state.name <<
                " does not have a doc property.") if curr_state.doc_property.nil?

           # if a state does not have transitions, then check to see if it has a location property (e.g. deleted, error)
           if  curr_state.transitions.nil?
             warnings << "\tWARNING  No location property defined for resource " << resource_type <<
                 "in state " << curr_state.name if  curr_state.location.nil?
           else

             curr_state.transitions.each do |transition|
                curr_transition = transition[1]
                #9
                errors << ("\tERROR:  No next property defined for resource " << resource_type <<  " in state " <<
                    curr_state.name << ", transition " << curr_transition.name) if  curr_transition.next.nil?
                #10 Transition next property has no value
                errors << ("\tERROR:  Empty next property defined for resource " << resource_type <<  " in state "  <<
                    curr_state.name << ", transition " << curr_transition.name) if !curr_transition.next.nil? && curr_transition.next.empty?
                #13 Transition collections property has no value(s)
                errors << ("\tERROR:  Condition property has no values for resource " << resource_type <<  " in state " <<
                    curr_state.name << ", transition " << curr_transition.name << ". Add conditions or delete this key.")  if curr_transition.empty_conditions_set
                 #11
                check_for_phantom_state_transitions(states, resource_type, curr_state.name, curr_transition, errors)
                #14
                warnings << ("\tWARNING: resource " << resource_type << ", state " << curr_state.name <<
                ", transition " << curr_transition.id << " name property is not 'self'.") if curr_transition.is_specified_name_property_not_self?
             end
           end
         end
       end
     end
   end

   #ugly, gotta be a better way...
   def self.get_states_for_secondary_descriptor registry, secondary_desc
     registry[secondary_desc].parent_descriptor.resource_descriptor.states[secondary_desc]
   end

   #11, check to see if any next transition maps to an existing state. Check for null values at every level.
   # No need to check if the next transition points to an external resource (e.g. 'location')
  def self.check_for_phantom_state_transitions states, secondary_descriptor, curr_state_name, curr_transition, errors
    if !curr_transition.next.nil? && is_next_transition_a_string?(curr_transition.next_state_name)
       errors << ("\tERROR:  Next property pointing to a state that is not specified in resource " << secondary_descriptor <<
           ", in state "  << curr_state_name << ", transition action " << curr_transition.name << ", 'next' transition "   <<
           curr_transition.next_state_name)  unless states.include?(curr_transition.next_state_name)
     end
  end

   def self.is_next_transition_a_string?(next_transition)
      next_transition.is_a?(String) ? true : false
   end

  def self.is_next_transition_a_location?(next_transition)
    next_transition.is_a?(Array) && next_transition[0].keys[0] == 'location' ? true : false
  end

   # Build a comprehensive list of all states in order to test for transitions pointing to nowhere (#11)
  def self.build_state_list(resource_names, registry, check_for_dups = true)
    state_array = []
    resource_names.each do |resource_type|
      get_states_for_secondary_descriptor(registry, resource_type).each do |state_transition|
        if state_array.include?(state_transition)
          errors << "\tERROR:  Duplicate state found in state section: " << state_transition if check_for_dups == true
        else
          state_array << state_transition[0]
        end
      end
    end
    state_array
  end

   # massive error
  def self.check_for_missing_sections filename, errors
    begin
       yml_out = YAML.load_file(filename)
     rescue Exception => exception
       errors << ("\tERROR: Unable to load file "<< filename << ": " << exception.message)
      return
    end

   # Using Yaml output, check for whoppers first
    MAJOR_SECTIONS.each do |section|
     if yml_out[section].nil?
       errors << ("\tERROR: " << section << " section missing from " << filename << " descriptor file")
     end
    end
  end

  def self.load_single_descriptor_file_into_registry filename, errors
     registry = {}
     begin
       registry = Crichton.single_registry(filename)
     rescue Exception => e
       errors << ("\tERROR: Unable to process registry file" << e.message)
     end
      registry
   end

   #When the dust settles, print out the results of the lint analysis
  def self.display_results  errors, warnings
    if errors.any?
      errors.each do |error|
        puts error
      end
    end

    if warnings.any?
      warnings.each do |warning|
        puts warning
      end
    end

    puts "resource descriptor file passes lint validation." unless (errors.any? || warnings.any?)
  end
end

